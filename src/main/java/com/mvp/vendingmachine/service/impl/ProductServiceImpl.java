package com.mvp.vendingmachine.service.impl;import com.mvp.vendingmachine.api.model.OrderedProduct;import com.mvp.vendingmachine.exception.*;import com.mvp.vendingmachine.service.ProductService;import com.mvp.vendingmachine.storage.MongoProductRepository;import com.mvp.vendingmachine.storage.MongoUserRepository;import com.mvp.vendingmachine.storage.model.StoredProduct;import com.mvp.vendingmachine.storage.model.StoredUser;import org.springframework.data.mongodb.core.FindAndModifyOptions;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Collections;import java.util.List;import static java.lang.String.format;@Servicepublic class ProductServiceImpl implements ProductService {    private static final String SELLER_ID_VALUE = "sellerId";    private static final String USERNAME_VALUE = "username";    private static final String DEPOSIT_VALUE = "deposit";    private static final String PRODUCT_NAME_VALUE = "productName";    private static final String AMOUNT_AVAILABLE_VALUE = "amountAvailable";    private static final String COST_VALUE = "cost";    private final MongoProductRepository mongoProductRepository;    private final MongoUserRepository mongoUserRepository;    private final MongoTemplate mongoTemplate;    public ProductServiceImpl(final MongoProductRepository mongoProductRepository, final MongoUserRepository mongoUserRepository, MongoTemplate mongoTemplate) {        this.mongoProductRepository = mongoProductRepository;        this.mongoUserRepository = mongoUserRepository;        this.mongoTemplate = mongoTemplate;    }    @Override    public StoredProduct createProduct(final StoredProduct storedProduct) throws UserNotFoundException, DuplicateProductException {        final String loggedUser = SecurityContextHolder.getContext().getAuthentication().getName();        final String username = mongoUserRepository.findById(loggedUser).orElseThrow(() -> new UserNotFoundException(format("User not found with name {}", loggedUser))).getUsername();        storedProduct.setSellerId(username);        try {            return mongoProductRepository.insert(storedProduct);        } catch (Exception exception) {            throw new DuplicateProductException(format("User with name [%s] already exist", storedProduct.getProductName()));        }    }    @Override    public StoredProduct findProductByProductName(String productName) throws ProductNotFoundException {        return mongoProductRepository.findById(productName).orElseThrow(() -> new ProductNotFoundException(format("Product not found with name {}", productName)));    }    @Override    public List<StoredProduct> findAllProducts() {        return mongoProductRepository.findAll();    }    @Override    public StoredProduct updateProduct(String productName, StoredProduct updateProduct) throws DuplicateProductException {        updateProduct.setProductName(productName);        final String loggedUser = getLoggedUser();        StoredProduct storedProduct = mongoTemplate.findAndModify(            Query.query(Criteria.where(SELLER_ID_VALUE).is(loggedUser).and(PRODUCT_NAME_VALUE).is(productName)),            Update.update(COST_VALUE, updateProduct.getCost()).set(AMOUNT_AVAILABLE_VALUE,                updateProduct.getAmountAvailable()),            FindAndModifyOptions.options().returnNew(true),            StoredProduct.class);        if (storedProduct == null) {            updateProduct.setProductName(productName);            updateProduct.setSellerId(loggedUser);            try {                return mongoTemplate.insert(updateProduct);            } catch (Exception exception) {                throw new DuplicateProductException(format("User with name [%s] already exist", productName));            }        }        return storedProduct;    }    @Override    public void deleteUserByProductName(String productName) {        final String loggedUser = getLoggedUser();        final StoredProduct response = mongoTemplate.findAndRemove(            Query.query(Criteria.where(SELLER_ID_VALUE).is(loggedUser).and(PRODUCT_NAME_VALUE).is(productName)),            StoredProduct.class);        if (response == null) {        }    }    @Override    public OrderedProduct buyProduct(final String productId, final Integer amountOfProducts) throws ProductNotFoundException, UserNotFoundException, AvailableProductException, InsufficientFundException {        final StoredProduct storedProduct = mongoProductRepository.findById(productId).orElseThrow(() -> {            return new ProductNotFoundException(format("Your product [%s] is not available!", productId));        });        final String username = getLoggedUser();        final StoredUser storedUser = mongoUserRepository.findById(username).orElseThrow(() -> {            return new UserNotFoundException(format("User not found with name [%s]", username));        });        if (storedUser.getDeposit() < storedProduct.getCost() * amountOfProducts) {            throw new InsufficientFundException("Insufficient funds. Please deposit!");        }        if (amountOfProducts > storedProduct.getAmountAvailable()) {            throw new AvailableProductException(format("There are only [%s] available of [%s]!", storedProduct.getAmountAvailable(), storedProduct.getProductName()));        }        mongoTemplate.findAndModify(            Query.query(Criteria.where(PRODUCT_NAME_VALUE).is(storedProduct.getProductName())),            Update.update(AMOUNT_AVAILABLE_VALUE, storedProduct.getAmountAvailable() - amountOfProducts),            StoredProduct.class);        final Integer totalSpent = amountOfProducts * storedProduct.getCost();        final Integer totalChange = storedUser.getDeposit() - totalSpent;        Integer remaining = totalChange;        mongoTemplate.findAndModify(            Query.query(Criteria.where(PRODUCT_NAME_VALUE).is(storedProduct.getProductName())),            Update.update(AMOUNT_AVAILABLE_VALUE, storedProduct.getAmountAvailable() - amountOfProducts),            StoredProduct.class);        final List<Integer> splittedChange = calculateChange(remaining);        final OrderedProduct orderedProductDto = new OrderedProduct();        orderedProductDto.setPurchasedProduct(storedProduct.getProductName());        orderedProductDto.setTotalSpent(totalSpent);        orderedProductDto.setChange(splittedChange);        mongoTemplate.findAndModify(            Query.query(Criteria.where(USERNAME_VALUE).is(username)),            Update.update(DEPOSIT_VALUE, totalChange),            FindAndModifyOptions.options().returnNew(true),            StoredUser.class        );        return orderedProductDto;    }    private List<Integer> calculateChange(Integer remaining) {        final List<Integer> defaultChangePattern = List.of(100, 50, 20, 10, 5);        final List<Integer> splittedChange = new ArrayList<>();        for (Integer coin : defaultChangePattern) {            splittedChange.add((int) Math.floor(remaining / coin));            remaining = remaining % coin;        }        Collections.reverse(splittedChange);        return splittedChange;    }    private static String getLoggedUser() {        return SecurityContextHolder.getContext().getAuthentication().getName();    }}