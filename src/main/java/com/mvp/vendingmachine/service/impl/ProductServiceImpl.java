package com.mvp.vendingmachine.service.impl;import com.mvp.vendingmachine.api.model.OrderedProduct;import com.mvp.vendingmachine.exception.AvailableProductException;import com.mvp.vendingmachine.exception.DuplicateProductException;import com.mvp.vendingmachine.exception.ProductNotFoundException;import com.mvp.vendingmachine.exception.UserNotFoundException;import com.mvp.vendingmachine.service.ProductService;import com.mvp.vendingmachine.storage.MongoProductRepository;import com.mvp.vendingmachine.storage.MongoUserRepository;import com.mvp.vendingmachine.storage.model.StoredProduct;import com.mvp.vendingmachine.storage.model.StoredUser;import lombok.extern.slf4j.Slf4j;import org.springframework.data.mongodb.core.FindAndModifyOptions;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Collections;import java.util.List;import static java.lang.String.format;@Service@Slf4jpublic class ProductServiceImpl implements ProductService {    private static final String SELLER_ID_VALUE = "sellerId";    private static final String PRODUCT_NAME_VALUE = "productName";    private static final String AMOUNT_AVAILABLE_VALUE = "amountAvailable";    private static final String COST_VALUE = "cost";    private final MongoProductRepository mongoProductRepository;    private final MongoUserRepository mongoUserRepository;    private final MongoTemplate mongoTemplate;    public ProductServiceImpl(final MongoProductRepository mongoProductRepository, final MongoUserRepository mongoUserRepository, MongoTemplate mongoTemplate) {        this.mongoProductRepository = mongoProductRepository;        this.mongoUserRepository = mongoUserRepository;        this.mongoTemplate = mongoTemplate;    }    @Override    public StoredProduct createProduct(final StoredProduct storedProduct) throws UserNotFoundException, DuplicateProductException {        final String loggedUser = SecurityContextHolder.getContext().getAuthentication().getName();        final String username = mongoUserRepository.findById(loggedUser).orElseThrow(() -> new UserNotFoundException(format("User not found with name {}", loggedUser))).getUsername();        log.info("Create product with name {}.", storedProduct.getProductName());        storedProduct.setSellerId(username);        try {            return mongoProductRepository.insert(storedProduct);        } catch (Exception exception) {            log.error("Product with name {} already exist. Please register another product!", storedProduct.getProductName());            throw new DuplicateProductException(format("User with name [%s] already exist", storedProduct.getProductName()));        }    }    @Override    public StoredProduct findProductByProductName(String productName) throws ProductNotFoundException {        log.info("Retrieve product with name {}.", productName);        return mongoProductRepository.findById(productName).orElseThrow(() -> new ProductNotFoundException(format("Product not found with name {}", productName)));    }    @Override    public List<StoredProduct> findAllProducts() {        log.info("Retrieving all products from db.");        return mongoProductRepository.findAll();    }    @Override    public StoredProduct updateProduct(String productName, StoredProduct updateProduct) throws DuplicateProductException {        updateProduct.setProductName(productName);        final String loggedUser = getLoggedUser();        log.info("Update product with name {}.", updateProduct.getProductName());        StoredProduct storedProduct = mongoTemplate.findAndModify(            Query.query(Criteria.where(SELLER_ID_VALUE).is(loggedUser).and(PRODUCT_NAME_VALUE).is(productName)),            Update.update(COST_VALUE, updateProduct.getCost()).set(AMOUNT_AVAILABLE_VALUE,                updateProduct.getAmountAvailable()),            FindAndModifyOptions.options().returnNew(true),            StoredProduct.class);        if (storedProduct == null) {            log.warn("Product {} cannot be updated by user {} because does not exist or was created by someone else!", productName, loggedUser);            updateProduct.setProductName(productName);            updateProduct.setSellerId(loggedUser);            try {                return mongoTemplate.insert(updateProduct);            } catch (Exception exception) {                log.error("Product with name {} already exist. Please register another product!", productName);                throw new DuplicateProductException(format("User with name [%s] already exist", productName));            }        }        return storedProduct;    }    @Override    public void deleteUserByProductName(String productName) {        log.info("Deleting product with name {}.", productName);        final String loggedUser = getLoggedUser();        final StoredProduct response = mongoTemplate.findAndRemove(            Query.query(Criteria.where(SELLER_ID_VALUE).is(loggedUser).and(PRODUCT_NAME_VALUE).is(productName)),            StoredProduct.class);        if (response == null) {            log.warn("You are not allowed to delete this product!");        }    }    @Override    public OrderedProduct buyProduct(final String productId, final Integer amountOfProducts) throws ProductNotFoundException, UserNotFoundException, AvailableProductException {        final StoredProduct storedProduct = mongoProductRepository.findById(productId).orElseThrow(() -> {            log.error("Your product {} is not available!", productId);            return new ProductNotFoundException(format("Your product [%s] is not available!", productId));        });        final String username = getLoggedUser();        final StoredUser storedUser = mongoUserRepository.findById(username).orElseThrow(() -> {            log.error("User not found with name {}!", username);            return new UserNotFoundException(format("User not found with name [%s]", username));        });        if (amountOfProducts >= storedProduct.getAmountAvailable()) {            log.error("There are only {} available of {}!", storedProduct.getAmountAvailable(), storedProduct.getProductName());            throw new AvailableProductException(format("There are only [%s] available of [%s]!", storedProduct.getAmountAvailable(), storedProduct.getProductName()));        }        mongoTemplate.findAndModify(            Query.query(Criteria.where(SELLER_ID_VALUE).is(username).and(PRODUCT_NAME_VALUE).is(storedProduct.getProductName())),            Update.update(AMOUNT_AVAILABLE_VALUE, storedProduct.getAmountAvailable()),            StoredProduct.class);        final Integer totalSpent = amountOfProducts * storedProduct.getCost();        final Integer totalChange = storedUser.getDeposit() - totalSpent;        Integer remaining = totalChange;        final List<Integer> splittedChange = calculateChange(remaining);        final OrderedProduct orderedProductDto = new OrderedProduct();        orderedProductDto.setPurchasedProduct(storedProduct.getProductName());        orderedProductDto.setTotalSpent(totalSpent);        orderedProductDto.setChange(splittedChange);        log.info("You bought {} {} and spent {}! Your change is {} cents splitted as follows [5, 10, 20, 50 and 100 cent coins]", amountOfProducts, productId, totalSpent, totalChange);        return orderedProductDto;    }    private List<Integer> calculateChange(Integer remaining) {        final List<Integer> defaultChangePattern = List.of(100, 50, 20, 10, 5);        final List<Integer> splittedChange = new ArrayList<>();        for (Integer coin : defaultChangePattern) {            splittedChange.add((int) Math.floor(remaining / coin));            remaining = remaining % coin;        }        Collections.reverse(splittedChange);        return splittedChange;    }    private static String getLoggedUser() {        return SecurityContextHolder.getContext().getAuthentication().getName();    }}